__author__ = "Jason M. Pittman"
__copyright__ = "Copyright 2024"
__credits__ = ["Jason M. Pittman"]
__license__ = "MIT License"
__version__ = "1.0.0"
__maintainer__ = "Jason M. Pittman"
__status__ = "Exercise"

""" Collatz Sequence:
A Collatz sequence is generated by repeatedly applying the following rules to an integer and then to each resulting integer in turn:

    If even: divide by 2.
    If odd: multiply by 3, then add 1.

The Collatz algorithm has been tested and found to always reach 1 for all positive integers.

Create a function that, when given two positive integers a b, returns the string "a" if integer a took fewer steps to reach 1 than b when passed through the Collatz sequence, or "b" if integer b took fewer steps to reach 1 than a.

Examples:

    collatz(10, 15) ➞ "a"
    # Because 10.0 - 5.0 - 16.0 - 8.0 - 4.0 - 2.0 - 1.0: 6 steps
    # 15.0 - 46.0 - 23.0 - 70.0 - 35.0 - 106.0 - 53.0 - 160.0 - 80.0 - 40.0 - 20.0 - 10.0 - 5.0 - 16.0 - 8.0 - 4.0 - 2.0 - 1.0: 17 steps

    collatz(13, 16) ➞ "b"
    collatz(53782, 72534) ➞ "b"

Started: Jan 09, 2024 @ 5:15am ET
Intervals: 1
Ended: Jan 09, 2024 @ 5:40am ET
"""
from sys import argv

def calculate_next_element(number: int) -> int:
    if number % 2 == 0:
        return number // 2
    else:
        return (number * 3) + 1

def generate_collatz(n: int, m: int) -> str:
    number_of_steps_N = 0
    number_of_steps_M = 0

    while n != 1:
        n = calculate_next_element(n)
        number_of_steps_N += 1
    
    while m != 1:
        m = calculate_next_element(m)
        number_of_steps_M += 1
    
    print(number_of_steps_N, number_of_steps_M)

    if number_of_steps_N < number_of_steps_M:
        return 'a'
    else:
        return 'b'

if __name__ == '__main__':
    n, m = argv[1].split(',')

    print(generate_collatz(int(n), int(m)))
